;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;TTYTEST.A65 -- Memory Tester for the KIM-1
;
;This program assumes a working KIM-1 and is intended to
;test external memory. It lives in the onboard 1K of SRAM.
;
;Testing or loading below 0x0400 will clobber the memory 
;test program!
;
;Commands are:
;
; * [T]est memory T:<start>,<end>
; * [L]oad memory L:<start>,<end>=<data>
; * [C]ompare memory C:<start>,<end>=<data>
;
;See README.md for a more detailed explanation of the tests,
;how to build from source, etc.
;
;(c) 2023 Glitch Works, LLC
;http://www.glitchwrks.com/
;
;Released under the GNU GPL v3, see LICENSE in project root.
;
;Exhaustive memory test based heavily on the routines from
;the OSI MEMORY TEST from OS-65D 2.0, published in OSI
;Small Systems Journal, Volume 1, Number 3, September 1977.
;
;Modifications by Mark Spankus for better output with OSI
;serial consoles.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;KIM-1 Equates
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GETCH	=	$1E5A		;A = char from TTY, clobbers Y
OUTCH	=	$1EA0		;Print A on tty, clobbers A and Y
OUTSP	=	$1E9E		;Print a space on TTY, clobbers A and Y

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Zero Page Variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CONTMP	=	$C3		;Temporary storage for CIN and COUT
USRCMD	=	$C4		;Command character entered by the user
PASCTR	=	$C5		;Pass Counter
VAR1	=	$C7		;Memory fill value
STARTL	=	$C8		;User-entered start address low byte
STARTH	=	$C9		;User-entered start address high byte
MEMPTL	=	$CA		;Current testing address low byte
MEMPTH	=	$CB		;Current testing address high byte
ENDADL	=	$CC		;User-entered end address low byte
ENDADH	=	$CD		;User-entered end address high byte

PXSTRT	=	$D0		;Current pattern start offset
PATBYT	=	$D1		;Current pattern byte
PXIDX	=	$D2		;Current pattern index
PXPREV	=	$D3		;Previous pattern byte

.segment "CODE"
START:	CLD			;No decimal mode
	SEI			;Interrupts masked
	JSR	CRLF		;send <CR><LF> to terminal

	LDA	#'?'
	JSR	COUT		; write '?' prompt

TMLUP:	JSR	CIN		;Test mode selection loop
	CMP	#'C'		;'C'ompare
	BEQ	L0224	
	CMP	#'L'		;'L'oad
	BEQ	L0224
	CMP	#'T'		;'T'est
	BNE	TMLUP		;No match? Loop again.

L0224:	STA	USRCMD		;store command
	LDA	#':'
	JSR	COUT		;Write ':' to screen for address start prompt

	LDX	#$00		;X is used to keep track of the number of characters in
INADDR:	JSR	CIN
	CMP	#$0D		;Return?
	BEQ	START		;Yes. Start over

	JSR	HEXCNV 		;Character to hex nibble
	BMI	INADDR		;Invalid hex character, try again.

	JSR	HEXSFT		;Shift the 4-bit value into paramter pointers

	INX
	CPX	#$04		;At 4th character?
	BMI	INADDR		;No, <4, get more characters
	BNE	L024B		;No, >4, check if we are done

	LDA	#','		;Output ','
	JSR	COUT

L024B:	CPX	#$08		;At 8 characters input?

L024D:	BMI	INADDR		;No, <8, get more characters
	BNE	L02AE		;No, >8, get extra byte for "Load"

	;We have 8 characters now
	LDA	USRCMD		;Get the user command that was received earlier
	AND	#$3F		;Mask off 6 bits ('C' -> $03, 'L' -> $0C, 'T' -> $14)
	CMP	#$14		;Test?
	BNE	L02A9		;No, get 2 more characters

;Fall through into the memory tester
	JSR	CRLF		;Print a CR,LF so that the test pass numbers are on the next line

	JMP	NEWTST		;Do the test

; Get more chars for C and L commands
L02A9:	LDA	#'='		;Output '='
	JSR	COUT

L02AE:	CPX	#$0A		;At 10th character?
	BMI	L024D		;No, get another one.

;Received 10th character
	LDA	USRCMD		;Get the user command that was received earlier
	AND	#$3F		;Mask off 6 bits ('C' -> $03, 'L' -> $0C, 'T' -> $14)
	CMP	#$03		;Compare?
	BEQ	STRCMP		;Yes, start compare function

;Load function entry pointer
;fill memory with VAR1 until end pointer ENDADL
	JSR	RESTRT
LDLUP:	LDA	VAR1		;Load the fill value
	STA	(MEMPTL),Y		;Store it at the current memory address
	JSR	INMPTR		;Increment the current memory address
	BNE	LDLUP		;Loop again if MEMPTL <> ENDADL

L02C7:	LDA	#' '	;Output a space
	JSR	COUT
	LDA	#'*'	;Output an asterisk
	JSR	COUT

;Carriage return wait loop
CRLUP:	JSR	CIN	;wait for keypress
	CMP	#$0D	;CR?
	BNE	CRLUP	;Loop if not a CR
	JMP	START	;Start from the beginning

;Compare function entry point
STRCMP:	JSR	RESTRT		;Restore START value to MEMPTL
L02DE:	LDA	VAR1
	CMP	(MEMPTL),Y
	BNE	TSTERR
	JSR	INMPTR
	BNE	L02DE
	BEQ	L02C7

;Diplay the test error code
;A contains the value that should have been read back
TSTERR:	STA	STARTH		;Save value for later
	LDA	(MEMPTL),Y
	STA	STARTL

;Output (MEMPTH,MEMPLO),STARTH,STARTL in the form
; MEMPTL GOOD BAD
	LDX	#$04		;Set up X to keep track of the bytes printed

L02F7:	LDA	#' '		;Outut a space
	JSR	COUT

L02FC:	LDA	VAR1,X
	JSR	HINOUT		;Output the high nybble
	LDA	VAR1,X
	JSR	LONOUT		;Output the low nybble

	DEX			;Move X to the next byte
	BEQ	CRLUP		;At end? Wait for CR and start program again.
	CPX	#$02		;Done printing the address?
	BEQ	L02F7		;Yes, =2, output a space
	BPL	L02FC		;No, <2, print the next byte
	BMI	L02F7		;Yes, >2, output another space

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INMPTR -- Increment Memory Pointer
;Increments the memory pointer and compares the new value
;  to ENDADL. Compare flags are set.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
INMPTR:	INC	MEMPTL		;Increment the low byte
	BNE	IMPCMP		;Didn't overflow, skip incrementing high byte
	INC	MEMPTL+1	;Increment the high byte
;Increment Memory Pointer CoMPare
IMPCMP:	LDA	MEMPTL+1	;Compare the high byte
	CMP	ENDADL+1
	BNE	IMPEND		;Return with Z flag clear if different
	LDA	MEMPTL		;Compare the low byte
	CMP	ENDADL

IMPEND:	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;RESTRT -- Restore Start
;Move the STARTL,STARTH pair into MEMPTL,MEMPTL+1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESTRT:	LDA	STARTL
	STA	MEMPTL
	LDA	STARTH
	STA	MEMPTL+1
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HEXSFT -- Hex Shift
;shift hex nybble from A into memory locations
;  A->VAR1->ENDADH->ENDADL->STARTH->STARTL 
;
;No echo for KIM-1 as the hardware does that for us.
;
;A contains the hex value to shift in
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HEXSFT:	PHA			;Preserve A for later
	ASL	A		;shift nybble up
	ASL	A
	ASL	A
	ASL	A

	LDY	#$04		;Y is used to keep track of the number of shifts
HXSLUP:	ROL	A		;shift nybble into memory locations
	ROL	VAR1
	ROL	ENDADH		;Ending address
	ROL	ENDADL
	ROL	STARTH		;Starting address
	ROL	STARTL

	DEY
	BNE	HXSLUP		;Shift again if Y is not 0
	PLA			;Restore A
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;NYBOUT -- Nybble Out
;Outputs the hex nybble in the lower 4 bits of A as a
;  single ASCII character
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NYBOUT:	ORA	#$30		;Place the value up in the ASCII range

	CMP	#':'		;Greater than '9'?
	BMI	NYBGUD		;Nope, output the character
	CMP	#'G'		;Greater than 'G'?
	BCS	NYBBAD		;Yes, skip outputting the character

	CLC			;Add 7 to push the value to A-F if it is greater than 9
	ADC #$07

NYBGUD:	JMP COUT		;Echo the character, and save an RTS by using a jmp.
NYBBAD:	RTS			;Nybble is not valid

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HINOUT -- High Nybble Out
;Outputs the hex nybble in the upper 4 bits of A as a
;  single ASCII character.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HINOUT:	LSR	A		;Shift the high nybble down
	LSR	A
	LSR	A
	LSR	A
	;Fall through to LONOUT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;LONOUT -- High Nybble Out
;Outputs the hex nybble in the lower 4 bits of A as a
;  single ASCII character.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LONOUT:	AND	#$0F
	BPL	NYBOUT ;always

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HEXCNV -- Hex Conversion
;
;Takes an ASCII character in A and converts it to its 4-bit
;  HEX value. Stores the result in A.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HEXCNV:	CMP	#$30
	BMI	HEXERR
	CMP	#$3A
	BMI	HEXMSK
	CMP	#$41
	BMI	HEXERR
	CMP	#$47
	BPL	HEXERR
	SEC
	SBC	#$07
HEXMSK:	AND	#$0F
	RTS
HEXERR:	LDA	#$80
	RTS
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CIN -- Get a character from the console
;
;Blocks until a character is available. Calls to KIM-1 ROM
;routines.
;
;pre: KIM-1 serial initialized
;post: A register contains received character
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CIN:	TYA			;Preserve Y register
	STA	CONTMP
	JSR	GETCH		;Get char from TTY
	PHA			;Save char on stack
	LDA	CONTMP		;Get contents of Y register
	TAY			;Restore it
	PLA			;A = char from TTY
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CRLF -- Print a carriage return and a linefeed to console
;
;Falls through to COUT.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CRLF:	LDA 	#$0D
	JSR 	COUT
	LDA 	#$0A

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;COUT -- Print a character to the console
;
;Call to KIM-1 ROM routines.
;
;pre: A register contains character to print
;post: character printed to console
;post: A register contains character that was printed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COUT:	PHA			;Save char to print
	TYA			;Preserve Y register
	STA	CONTMP
	PLA			;A = char to print
	PHA			;Back on the stack
	JSR	OUTCH		;Print A to TTY
	LDA	CONTMP		;Restore Y register
	TAY
	PLA			;Restore A register.
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;NEWTST -- New memory test algorithm
;
;Falls through to NXTPAS
;
;Run Martin Eberhard's MTEST4.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NEWTST:	LDA	#$00
	STA	PASCTR		;Zero the pass counter
	LDY	#PATLEN+1	;Y = initial pattern start
	STY	PXSTRT		;Save to the pattern start variable
	INC	STARTL
	DEC	ENDADL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;NXTPAS - Main memory test loop
;
;This routine has been adapted from Martin Eberhard's MTEST4
;for Altair 680.
;
;Falls through to NXTBYT.
;
;pre: STARTL, STARTH contain starting address
;pre: ENDADL, ENDADH contain ending address
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NXTPAS:	LDA	STARTL		;Set up current memory pointer
	STA	MEMPTL
	LDA	STARTH
	STA	MEMPTH
	LDY	PXSTRT		;Get the current pattern start
	STY	PXIDX

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;NXTBYT -- Test and write the next byte in memory
;
;This routine has been adapted from Martin Eberhard's MTEST4
;for Altair 680.
;
;Due to architecture limitations, we can't do the "torture
;test" that Martin does by flipping the byte in memory fast
;several times.
;
;pre: MEMPTL, MEMPTH point to an address in the test range
;pre: ENDADL, ENDADH contain the ending address
;pre: Y register contains index into test pattern
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NXTBYT:	DEC	PXIDX		;Decrement index to next pattern byte
	BNE	NXTBY1		;Nonzero, continue
	LDY	PXSTRT+1	;Zero, reload from the current pattern start
	STY	PXIDX		;Store it in the index var
NXTBY1:	LDY	PXIDX		;Index to next pattery byte
	LDA	PATTRN, Y	;Get next pattern entry
	STA	PATBYT		;Save it

	LDA	#$00
	CMP	PASCTR		;Are we on the first pass?
	BEQ	NXTBY3		;First pass, don't read test yet

	INY			;Going to verify, get previous element
	LDA	PATTRN, Y
	STA	PXPREV
NXTBY2:	LDY	#$00
	LDA	(MEMPTL), Y	;Get currently addressed memory contents
	CMP	PXPREV		;Compare to the previous pattern byte
	BEQ	NXTBY3		;OK, keep going
	JSR	PRTERR		;Display error message


NXTBY3:	LDA	PATBYT		;Get pattern byte
	LDY	#$00		;Clear index
	STA	(MEMPTL), Y	;Store it at current address

; Maybe come up with something to stress the location here? Martin used
; a direct memory COM in the 6800 version, but we don't have that.

	INC	MEMPTL		;Increment memory pointer low byte
	BNE	NXTBY4		;No overflow, continue
	INC	MEMPTH		;Increment memory pointer high byte

NXTBY4:	LDA	MEMPTL		;A = low byte of memory pointer
	CMP	ENDADL		;Compare to low byte ending address
	BNE	NXTBYT		;Not there yet, keep going
	LDA	MEMPTH		;A = high byte of memory pointer
	CMP	ENDADH		;Compare to high byte ending address
	BNE	NXTBYT		;Not done yet, keep going

;Print the pass number here?

	LDA	#'.'		;Print pass activity indicator
	JSR	COUT	

	INC	PASCTR		;Increment pass counter
	DEC	PXSTRT		;Bump pattern start point
	BNE	NXTPAS		;Next pass through memory

DONE:	LDA	#'*'		;Print done indicator
	JSR	COUT
DONE1:	BNE	DONE1		;Get stuck in a loop	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTERR -- Print a memory test error
;
;pre: MEMPTL, MEMPTH point to the address of the error
;pre: A register contains the byte read from memory
;pre: PATBYT contains the expected byte
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTERR:	PHA			;Save byte read from memory on stack
	JSR	PRTADR		;Print the address of the error
	JSR	OUTSP		;Print a space, KIM-1 ROM routine
	PLA			;Restore byte read from memory
	JSR	PRTHEX		;Print the byte read from memory
	JSR	OUTSP		;Print a space, KIM-1 ROM routine
	LDA	PATBYT		;A = expected byte
	JSR	PRTHEX		;Print expected byte
	RTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTADR -- Print an address to the console
;
;Prints CR, LF, 16-bit address, a space, and a colon. 
;Destroys A register contents.
;
;Returns through COUT.
;
;pre: MEMPTL, MEMPTH contains address to print
;post: address printed to console as hex
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTADR: JSR	CRLF
	LDA	MEMPTH
	JSR	PRTHEX
	LDA	MEMPTL
	JSR	PRTHEX
	LDA	#':'
	JMP	COUT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTHEX -- Output byte to console as hex
;
;Falls through to PRTNIB.
;
;pre: A register contains byte to be output
;post: byte is output to console as hex
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTHEX: PHA			;Save A register on stack
	LSR			;Rotate high nybble down
	LSR
	LSR
	LSR
	JSR	PRTNIB		;Print high nybble
	PLA			;Restore A register

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTNIB -- Print hex nybble on console
;
;Returns through COUT.
;
;pre: A register contains nybble
;post: nybble printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTNIB:	AND	#$0F
	ORA	#'0'		;Add ASCII bias
	CMP	#':'		;0x0 - 0x9?
	BCC	PRTNI1
	ADC	#$06		;Add hex bias
PRTNI1:	JMP	COUT
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PATTRN -- Test pattern sequence
;
;This pattern is taken directly from Martin Eberhard's
;MTEST4 program for the Altair 680. From his comments:
;
;  Test pattern sequence, a prime number in length. Designed
;  to cause a lot of bit-flipping and to catch any bit-
;  coupling and address-coupling problems.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PATTRN:	.byte	$01, $FE, $02, $FD, $04, $FB, $08, $F7
	.byte	$10, $EF, $20, $FD, $40, $BF, $80, $7F
	.byte	$00, $FF, $55, $AA, $33, $CC, $F0, $0F
	.byte	$C3, $3C, $66, $99, $78
PATEND:	.byte	$01

PATLEN	=	PATEND - PATTRN	;Pattern length
